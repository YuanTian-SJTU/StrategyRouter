{"sample_order": 9, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid strategy of Best Fit and Worst Fit.\n\n    Hybrid strategy: Prioritize bins where the item fits best (smallest remaining capacity after adding item),\n    but also consider bins with largest remaining capacity to potentially reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacities after adding item\n    remaining = bins - item\n    # Create mask for bins that can actually fit the item\n    fits = remaining > 0\n\n    # Best fit component (inverse of remaining capacity)\n    best_fit = np.zeros_like(bins)\n    best_fit[fits] = 1.0 / remaining[fits]\n\n    # Worst fit component (remaining capacity)\n    worst_fit = np.zeros_like(bins)\n    worst_fit[fits] = remaining[fits]\n\n    # Combined score: normalize components and weight them (0.7 for best fit, 0.3 for worst fit)\n    norm_best = (best_fit - np.min(best_fit)) / (np.ptp(best_fit) if np.ptp(best_fit) != 0 else 1)\n    norm_worst = (worst_fit - np.min(worst_fit)) / (np.ptp(worst_fit) if np.ptp(worst_fit) != 0 else 1)\n    priorities = 0.7 * norm_best - 0.3 * norm_worst\n\n    return priorities\n\n", "score": -212.15}