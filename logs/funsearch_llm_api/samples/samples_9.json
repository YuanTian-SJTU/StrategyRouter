{"sample_order": 9, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid of Best Fit and Greedy strategies.\n\n    This function combines the Best Fit strategy, which aims to place the item in the bin that is the closest fit without exceeding the bin's capacity, with a Greedy approach that prioritizes bins with the most remaining space to minimize the number of partially filled bins. The priorities are calculated based on a weighted sum of the Best Fit and Greedy scores.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: preferring bins with the least leftover space\n    best_fit_scores = bins - item\n    best_fit_scores[best_fit_scores < 0] = np.inf  # Exclude bins that are too small\n\n    # Greedy component: preferring bins with the most remaining space\n    greedy_scores = bins\n\n    # Combine the two strategies with a weighted sum\n    alpha = 0.5  # Weight for Best Fit\n    beta = 0.5   # Weight for Greedy\n    combined_scores = (alpha * (1 / best_fit_scores)) + (beta * greedy_scores)\n\n    # Normalize the scores to ensure they are comparable\n    normalized_scores = (combined_scores - np.min(combined_scores)) / (np.max(combined_scores) - np.min(combined_scores))\n\n    return normalized_scores\n\n", "score": -377.5}