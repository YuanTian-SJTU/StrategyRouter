{"sample_order": 9, "strategy": "Hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Hybrid Best Fit and First Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacities\n    remaining_capacities = bins - item\n    \n    # Filter out bins that cannot fit the item\n    can_fit = remaining_capacities >= 0\n    remaining_capacities = remaining_capacities[can_fit]\n    \n    if len(remaining_capacities) == 0:\n        return np.array([])  # No bin can fit the item\n    \n    # Best Fit component: prioritize bins with smallest remaining capacity that can fit the item\n    best_fit_scores = np.where(can_fit, -remaining_capacities, np.inf)\n    \n    # First Fit component: prioritize bins in order they were filled,modified slightly to fit Harmonic\n    # This encourages using bins that have been recently filled (to minimize fragmentation)\n    first_fit_scores = np.where(can_fit, np.arange(len(bins))[can_fit], np.inf)\n    \n    # Combine the strategies: weight best fit more heavily to minimize fragmentation\n    combined_scores = 0.7 * best_fit_scores + 0.3 * first_fit_scores\n    \n    # Create full priority array (inf for bins that can't fit the item)\n    priority = np.full_like(bins, np.inf)\n    priority[can_fit] = combined_scores\n    \n    return priority\n\n", "score": null}