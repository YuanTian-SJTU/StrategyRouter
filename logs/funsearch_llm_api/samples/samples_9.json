{"sample_order": 9, "strategy": "best_fit", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacities after adding the item\n    remaining = bins - item\n\n    # Flag bins that cannot accommodate the item\n    cannot_fit = (remaining < 0)\n    \n    # Initialize priorities with the remaining capacities\n    priorities = remaining.copy()\n\n    # Assign a very low priority to bins that cannot fit the item\n    priorities[cannot_fit] = -np.inf\n\n    # In case of ties, prefer bins with the same item size to avoid fragmentation\n    same_size = (bins == item + item)\n    priorities[same_size] -= 0.1\n\n    # Return the optimized priorities\n    return priorities\n\n", "score": null}