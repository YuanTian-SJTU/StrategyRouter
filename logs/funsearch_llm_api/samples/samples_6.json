{"sample_order": 6, "strategy": "best_fit", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Best Fit strategy.\n    \n    In this version, the priority score is calculated as the negative of the logarithm of the\n    ratio of the remaining capacity of the bin to the item size. This ensures that bins with\n    the closest fit (i.e., remaining capacity just larger than the item size) get the highest\n    priority. The use of logarithm helps to penalize over-sized bins more gently compared to\n    a linear approach.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin after adding the item\n    remaining_capacities = bins - item\n    # Filter out negative capacities (bins that cannot fit the item)\n    valid_capacities_mask = remaining_capacities > 0\n    # Calculate ratios for valid bins\n    ratios = remaining_capacities[valid_capacities_mask] / item\n    # Apply logarithm and negate to get priority scores\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    # Return an array of priorities with the same shape as bins, with -infinity for invalid bins\n    return np.where(valid_capacities_mask, priorities, -np.inf)\n\n", "score": null}