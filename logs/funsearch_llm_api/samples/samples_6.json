{"sample_order": 6, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid strategy.\n\n    Hybrid strategy combines Best Fit and Worst Fit by prioritizing bins that have a capacity\n    just enough to fit the item (Best Fit) but also considering bins that have a large remaining\n    capacity (Worst Fit) to potentially improve future placements.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit part: prioritize bins that can fit the item with minimal remaining space\n    best_fit_scores = 1 / (1 + np.abs(bins - item))\n    \n    # Worst Fit part: prioritize bins with large remaining capacity\n    worst_fit_scores = bins / (bins + item)\n    \n    # Hybrid: weighted sum of Best Fit and Worst Fit scores\n    hybrid_scores = 0.6 * best_fit_scores + 0.4 * worst_fit_scores\n    \n    return np.nan_to_num(hybrid_scores, nan=0.0)\n\n", "score": -333.9}