{"sample_order": 6, "strategy": "first_fit", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n\n    This strategy calculates the priority based on the smallest remaining capacity in the bin \n    that is still sufficient to accommodate the item, thus promoting tighter packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining_capacities = bins - item\n    valid_bins_mask = remaining_capacities >= 0  # Only consider bins with enough space\n    \n    # Initialize priorities with high values for invalid bins\n    priorities = np.full_like(bins, np.inf)\n    \n    # Calculate priorities for valid bins\n    valid_remaining_capacities = remaining_capacities[valid_bins_mask]\n    priorities[valid_bins_mask] = valid_remaining_capacities\n    \n    # Sort valid bins in ascending order of remaining capacity\n    sorted_indices = np.argsort(valid_remaining_capacities)\n    # Assign priorities in descending order (best fit first)\n    priorities[valid_bins_mask] = -np.sort(-valid_remaining_capacities)\n    \n    return priorities\n\n", "score": -212.75}