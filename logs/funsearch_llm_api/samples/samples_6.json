{"sample_order": 6, "strategy": "Hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid Best-Fit and Least-Remaining-Space strategy.\n\n    This strategy first identifies bins that can fit the item (Best-Fit), then among those, \n    prioritizes the bin with the least remaining space after placement (Least-Remaining-Space). \n    If no bin can fit, it returns negative infinity priorities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # 1. Initial Priority: Identify valid bins (Best-Fit first check)\n    valid_bins_mask = bins > item\n    initial_priorities = np.where(valid_bins_mask, -np.inf, np.inf) # Big penalty for invalid bins\n\n    # 2. Prioritize Best-Fit among valid bins\n    # Calculate \"fitness\" as how close the remaining space is to the item size (a smaller positive remainder is better)\n    # Only consider valid bins\n    if np.any(valid_bins_mask): # Check if there are any valid bins\n        remaining_space = bins[valid_bins_mask] - item\n        # Penalize bins with zero remaining space heavily to avoid waste, give preference to bins with small positive remaining space\n        fitness_scores = np.where(remaining_space == 0, 1, np.abs(remaining_space))\n        min_fitness = np.min(fitness_scores)\n        # Give highest priority (-lowest score) to bins with the best fitness (lowest 'fitness_scores')\n        best_fit_indices_mask = fitness_scores == min_fitness\n        initial_priorities[valid_bins_mask] = np.where(best_fit_indices_mask, -0.1, initial_priorities[valid_bins_mask]) # A score close to zero for best fit\n\n    # 3. At this point, 'initial_priorities' contains small positive scores for non-valid bins,\n    #    and potentially small negative scores (-0.1) for best fit bins.\n    #    We now refine the priority for *all* potentially valid bins (those not initially infinit).\n    #    We want to favor bins with least *positive* remaining space.\n\n    # Create a temporary array for calculation\n    refinement_priorities = np.full_like(bins, np.inf) #\n\n", "score": -212.75}