{"sample_order": 6, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Greedy Best-Worst Fit Hybrid strategy.\n\n    This strategy combines the Best Fit and Worst Fit approaches. It first calculates the standard Best Fit\n    priority (lowest remaining space after adding the item), then adjusts it based on the item size and remaining\n    bin capacity. Additionally, for very small items, it gives preference to bins with more remaining capacity,\n    resembling a Worst Fit approach for small items, to potentially reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: penalty based on remaining space after insertion\n    remaining_space = bins - item\n    best_fit_penalty = np.where(remaining_space > 0, remaining_space, 1e9)  # Penalize bins that cannot fit\n\n    # Threshold to switch towards Worst Fit behavior for small items\n    small_item_threshold = 0.2\n    scale_factor = 5.0  # Amplifies the preference for larger remaining space when item is small\n\n    # Adjust penalty for small items by also considering the remaining capacity\n    is_small_item = item < small_item_threshold\n    adjusted_penalty = np.where(\n        is_small_item,\n        best_fit_penalty * (1 - scale_factor * (1 - (bins / (bins.max() + 1e-6)))),\n        best_fit_penalty\n    )\n\n    # Final priority: lower score is better\n    return adjusted_penalty\n\n", "score": -377.5}