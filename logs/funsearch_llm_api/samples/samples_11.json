{"sample_order": 11, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid Best-Fit and Greedy strategy.\n\n    This strategy combines elements of Best Fit and Greedy strategies. It prioritizes bins that can fit\n    the item without exceeding capacity (Greedy), but also considers how much space would remain after\n    adding the item (Best Fit). The priority is calculated as a combination of the remaining capacity\n    (Greedy aspect) and the log of the ratio of item size to remaining capacity (Best Fit aspect).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacities\n    remaining = bins - item\n    \n    # Filter out bins that cannot fit the item\n    feasible = remaining[remaining >= 0]\n    \n    # Calculate Best Fit component (lower is better)\n    best_fit = np.log(item / remaining[remaining >= 0])\n    \n    # Calculate Greedy component (higher is better)\n    greedy = remaining[remaining >= 0]\n    \n    # Combine components: lower priority is better\n    # We want to maximize remaining space while keeping item proportion moderate\n    priorities = -2.0 * best_fit + 1.0 * greedy\n    \n    # Create priority array with -inf for infeasible bins\n    full_priorities = np.full_like(bins, -np.inf)\n    full_priorities[remaining >= 0] = priorities\n    \n    return full_priorities\n\n", "score": -500.0}