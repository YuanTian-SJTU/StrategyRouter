{"sample_order": 11, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a Hybrid Greedy-Best Fit strategy.\n\n    This strategy combines the Best Fit approach (taking the bin with the smallest remaining capacity\n    that can fit the item) with a Greedy component that slightly favors bins that have more leftover\n    space as it might lead to better packing efficiency in subsequent steps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: prioritize bins closest to filling up, but can accommodate the item\n    candidate_bins = bins >= item\n    if not np.any(candidate_bins):\n        return np.full_like(bins, np.inf)  # No bin can fit, set high priorities (will lead to rejection)\n\n    bf_scores = np.where(candidate_bins, -bins, np.inf)\n    \n    # Greedy component: favor bins with larger remaining space\n    gf_scores = bins\n\n    # Hybrid score: combine the scores. Weigh Best Fit more heavily.\n    # This gives preference to slightly tighter bins but also considers overall remaining space.\n    hybrid_score = 0.7 * bf_scores + 0.3 * gf_scores\n\n    # Invert the score for prioritization (lower score -> higher priority)\n    # Add a small constant to avoid potential divide by zero in case of exact fits (though unlikely here)\n    hybrid_score = -hybrid_score\n\n    return hybrid_score\n\n", "score": null}