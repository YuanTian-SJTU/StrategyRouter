{"sample_order": 11, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Hybrid strategy combining Best Fit and Worst Fit approaches.\n\n    This strategy uses a hybrid approach by combining elements of the Best Fit and Worst Fit strategies.\n    It assigns a higher priority to bins that are closest to the item size (Best Fit) but also gives some\n    consideration to bins that have the most available space (Worst Fit). This hybrid approach aims to\n    balance the benefits of both strategies to potentially improve the overall packing efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    best_fit_ratios = item / bins\n    best_fit_log_ratios = np.log(best_fit_ratios)\n    best_fit_priorities = -best_fit_log_ratios\n\n    worst_fit_ratios = (bins - item) / bins\n    worst_fit_log_ratios = np.log(worst_fit_ratios)\n    worst_fit_priorities = -worst_fit_log_ratios\n\n    # Combine the priorities with a weighted sum\n    alpha = 0.7  # Weight for Best Fit (can be tuned)\n    hybrid_priorities = alpha * best_fit_priorities + (1 - alpha) * worst_fit_priorities\n\n    return hybrid_priorities\n\n", "score": -325.5}