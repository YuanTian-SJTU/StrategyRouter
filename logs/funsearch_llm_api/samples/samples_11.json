{"sample_order": 11, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a combined Greedy and Best Fit strategy.\n\n    This strategy combines the Best Fit approach, which selects the bin with the smallest remaining\n    space that can accommodate the item, with a greedy component that also considers the ratio of\n    the item size to the remaining bin capacity. The greedy score is the negative of the log of the\n    ratio to balance between filling bins and not leaving too much space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    can_fit = bins >= item\n    if not np.any(can_fit):\n        return np.full_like(bins, np.inf)\n    \n    # Best Fit component: prioritize bins that leave the least remaining space\n    best_fit_scores = np.where(can_fit, item / (bins - item), np.inf)\n    \n    # Greedy component: prioritize smaller remaining space ratios\n    greedy_scores = np.where(can_fit, -(np.log(item / bins)), np.inf)\n    \n    # Combined score: weighted sum of best fit and greedy scores\n    combined_scores = 0.6 * best_fit_scores + 0.4 * greedy_scores\n    \n    return combined_scores\n\n", "score": null}