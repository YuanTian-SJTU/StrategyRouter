{"sample_order": 11, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a complex hybrid strategy \n    combining First Fit, Best Fit, and Worst Fit with a gradient descent inspired approach.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # First Fit component: prioritize the first bin that can accommodate the item\n    first_fit_scores = np.where(bins >= item, np.arange(len(bins), dtype=float), -np.inf)\n    first_fit_priority = -np.sort(-first_fit_scores)[::-1]\n\n    # Best Fit component: prioritize bins that can accommodate the item with the least remaining space\n    best_fit_scores = -np.abs(bins - item) if bins >= item else -np.inf\n\n    # Worst Fit component: prioritize bins that have the most remaining space\n    worst_fit_scores = bins if bins >= item else -np.inf\n\n    # Greedy component: prioritize bins that leave the most remaining space after accommodating the item\n    greedy_scores = (bins - item) if bins >= item else -np.inf\n\n    # Combine the scores with weights that dynamically change based on the item size\n    weight_first_fit = 0.2 if item < 0.5 else 0.1\n    weight_best_fit = 0.5 - 0.2 * (item < 0.5)\n    weight_worst_fit = 0.2 + 0.2 * (item < 0.5)\n    weight_greedy = 0.1\n\n    # Hybrid score: combine all components with weights\n    hybrid_scores = (weight_first_fit * first_fit_priority +\n                     weight_best_fit * best_fit_scores +\n                     weight_worst_fit * worst_fit_scores +\n                     weight_greedy * greedy_scores)\n\n    return hybrid_scores\n\n", "score": null}