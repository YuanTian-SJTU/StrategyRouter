{"sample_order": 3, "strategy": "Hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Retrieves priority using a Hybrid strategy that merges Best Fit and First Fit criteria.\n\n    The priority score for each bin is determined by a composite strategy:\n    - It incorporates the depth of a bin's capacity (Best Fit)\n    - It also incorporates the least load in the bin relative to total capacity (First Fit)\n    The final score is the harmonic mean of the two metrics for each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of currently available capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority scores.\n    \"\"\"\n    # Prevent division by zero for empty bins\n    safe_bins = bins + 1e-10\n    \n    # Calculate Best Fit criterion: Minimize remaining space after addition\n    best_fit_scores = (bins - item) * -1\n    \n    # Calculate First Fit criterion: Least loaded bins first\n    load_ratios = item / safe_bins\n    first_fit_scores = 1 - load_ratios\n    \n    # Calculate harmonic mean of both scores\n    sum_inverse = 1/best_fit_scores + 1/first_fit_scores\n    priority_scores = 2 / sum_inverse\n    \n    return priority_scores\n\n", "score": -500.0}