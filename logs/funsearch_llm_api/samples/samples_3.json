{"sample_order": 3, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid First Fit and Best Fit strategy.\n\n    The priority is calculated by combining the advantages of First Fit (which finds the first available bin) and \n    Best Fit (which finds the bin that fits the item the best). The priority score is a weighted sum of the remaining \n    space after placement and a penalty for not being a perfect fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining_space = bins - item\n    valid_bins = remaining_space >= 0\n\n    # First Fit: prioritize bins that have enough space (earlier bins get higher priority)\n    first_fit_priority = np.where(valid_bins, 1 / (np.arange(len(bins)) + 1), -np.inf)\n\n    # Best Fit: prioritize bins that leave the least remaining space\n    best_fit_priority = -np.where(valid_bins, remaining_space, np.inf)\n\n    # Hybrid: Combine First Fit and Best Fit with weights (weights can be adjusted)\n    hybrid_priority = 0.6 * first_fit_priority + 0.4 * best_fit_priority\n\n    return hybrid_priority\n\n", "score": -212.0}