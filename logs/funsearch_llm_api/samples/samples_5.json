{"sample_order": 5, "strategy": "best_fit", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n    \n    The priority is calculated as the difference between the bin capacity and the item size,\n    ensuring that the bin can accommodate the item. The bin with the smallest positive remaining\n    capacity (most tightly fitting) is given the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n        \n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining_capacities = bins - item\n    # Filter out bins that cannot accommodate the item\n    valid_bins = remaining_capacities[remaining_capacities >= 0]\n    if len(valid_bins) == 0:\n        # If no bin can accommodate the item, return -inf for all bins\n        return np.full_like(bins, -np.inf)\n    \n    # Prioritize bins with the smallest remaining capacity (best fit)\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -np.inf)\n    return priorities\n\n", "score": null}