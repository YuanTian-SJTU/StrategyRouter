{"sample_order": 5, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a hybrid strategy combining Best Fit and Worst Fit.\n\n    Best Fit prioritizes bins that can accommodate the item with the least remaining space after placement.\n    Worst Fit prioritizes bins that can accommodate the item with the most remaining space after placement.\n    The hybrid strategy gives a higher priority to a bin if it scores well in either Best Fit or Worst Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate remaining space after placing the item in each bin\n    remaining_space = bins - item\n    \n    # Check if the item can fit into each bin\n    can_fit = remaining_space >= 0\n    \n    # Initialize priorities to negative infinity\n    priorities = np.full_like(bins, -np.inf, dtype=np.float64)\n    \n    # Best Fit priority: bins that leave the least remaining space\n    best_fit_priority = -remaining_space\n    \n    # Worst Fit priority: bins that leave the most remaining space\n    worst_fit_priority = remaining_space\n    \n    # Combine Best Fit and Worst Fit priorities\n    combined_priority = np.maximum(best_fit_priority, worst_fit_priority)\n    \n    # Set the priority for bins that can fit the item\n    priorities[can_fit] = combined_priority[can_fit]\n    \n    return priorities\n\n", "score": -500.0}