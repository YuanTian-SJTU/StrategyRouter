{"sample_order": 2, "strategy": "Hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid strategy combining Best Fit and Worst Fit.\n\n    The strategy first identifies bins that can accommodate the item (capacity >= item), then:\n    1. Assigns higher priority to bins with smallest remaining capacity (Best Fit approach).\n    2. Among such bins, assigns even higher priority to bins with largest remaining capacity (Worst Fit approach).\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    can_fit = bins >= item\n    priorities = np.zeros_like(bins)\n    \n    # First, assign priority only to bins that can fit the item\n    priorities[can_fit] = 1000  # Initial high priority for feasibility\n    \n    # Among feasible bins, apply hybrid strategy\n    if np.any(can_fit):\n        feasible_bins = bins[can_fit]\n        \n        # Best Fit component: bins with smaller remaining capacity get higher priority\n        best_fit_scores = 1.0 / feasible_bins\n        best_fit_scores = -(best_fit_scores - np.max(best_fit_scores))  # Higher score for smaller bins\n        \n        # Worst Fit component: among best candidates, prefer larger remaining capacity\n        worst_fit_scores = feasible_bins / np.max(feasible_bins)\n        \n        # Combine both components\n        hybrid_scores = 0.7 * best_fit_scores + 0.3 * worst_fit_scores\n        max_hybrid = np.max(hybrid_scores)\n        if max_hybrid > 0:\n            max_hybrid = np.log1p(max_hybrid)  # Apply log scaling to limit range\n            \n        priorities[can_fit] += hybrid_scores + max_hybrid * 0.1  # Small weight to hybrid component\n    \n    return priorities\n\n", "score": null}