{"sample_order": 2, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: prioritize bins where the item fits with the smallest remaining space\n    remaining_space = bins - item\n    valid_bins = np.where(remaining_space >= 0)[0]\n    best_fit_scores = np.full(len(bins), -np.inf)\n    if len(valid_bins) > 0:\n        best_fit_scores[valid_bins] = bins[valid_bins] - item\n    \n    # Additional constraint: prioritize bins that are closest to full but still have space\n    fill_level = item / bins\n    fill_scores = np.log(1 + fill_level)  # Higher score for bins closer to full\n    \n    # Hybrid score combining both criteria\n    hybrid_scores = best_fit_scores + 3 * fill_scores\n    \n    # For bins that can't fit the item, set a low priority (negative)\n    hybrid_scores[valid_bins] = np.where(hybrid_scores[valid_bins] > 0, \n                                        hybrid_scores[valid_bins], -np.inf)\n    \n    return hybrid_scores\n\n", "score": -500.0}