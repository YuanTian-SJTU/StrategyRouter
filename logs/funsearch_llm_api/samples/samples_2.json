{"sample_order": 2, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a Hybrid Fit strategy.\n\n    This strategy combines aspects of Best Fit, First Fit, and a capacity-weighted approach to prioritize \n    bins that not only have the closest remaining capacity to the item's size but also those with a higher \n    remaining capacity, while penalizing bins that are nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: prioritize bins where remaining capacity is closest to the item size\n    remaining = bins - item\n    valid_bins = remaining >= 0\n    remaining_invalid = np.where(valid_bins, remaining, np.inf)\n    best_fit_priority = -np.abs(remaining_invalid)\n    \n    # First Fit component: prioritize bins in original order (simulated by index priority)\n    first_fit_priority = -(np.arange(len(bins)) * (remaining >= 0).astype(float))\n    \n    # Greedy component: prioritize bins with higher remaining capacity\n    greedy_priority = remaining * (remaining >= 0).astype(float)\n    \n    # Hybrid score combining all three components with weights\n    hybrid_score = 0.5 * best_fit_priority + 0.3 * first_fit_priority + 0.2 * greedy_priority\n    \n    return hybrid_score\n\n", "score": null}