{"sample_order": 2, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid Best Fit and Worst Fit strategy.\n\n    This strategy combines the Best Fit and Worst Fit approaches to balance between filling nearly full bins and spreading out items across bins. It assigns higher priority to bins that are well-suited for the item (Best Fit) while also considering bins that are less filled (Worst Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    best_fit_ratios = item / bins\n    best_fit_priorities = -np.log(best_fit_ratios)\n\n    worst_fit_ratios = (1 - (item / bins))\n    worst_fit_priorities = np.log(worst_fit_ratios)\n\n    # Combine the priorities with a weighted sum\n    hybrid_priorities = 0.7 * best_fit_priorities + 0.3 * worst_fit_priorities\n    return hybrid_priorities\n\n", "score": -500.0}