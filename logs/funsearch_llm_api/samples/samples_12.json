{"sample_order": 12, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a Hybrid Best and Worst Fit strategy.\n\n    This strategy combines the principles of Best Fit and Worst Fit to find a balance between efficient bin usage and\n    flexibility in handling larger items. It calculates a priority score for each bin as the sum of two components:\n    1. The negative natural logarithm of the ratio of item size to remaining bin capacity (Best Fit component).\n    2. The ratio of remaining bin capacity to item size (Worst Fit component).\n\n    The final priority score is the combination of these two components, weighted by a factor of 0.6 for the Best Fit\n    component and 0.4 for the Worst Fit component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.any(bins <= 0):\n        raise ValueError(\"Bins must have positive capacities.\")\n    if item <= 0:\n        raise ValueError(\"Item size must be positive.\")\n    \n    # Best Fit component\n    best_fit_scores = -np.log(item / bins)\n    \n    # Avoid division by zero\n    bins_safe = np.where(bins == 0, np.inf, bins)\n    # Worst Fit component\n    worst_fit_scores = bins_safe / item\n    \n    # Combine the scores with weights\n    priorities = 0.6 * best_fit_scores + 0.4 * worst_fit_scores\n    \n    return priorities\n\n", "score": -500.0}