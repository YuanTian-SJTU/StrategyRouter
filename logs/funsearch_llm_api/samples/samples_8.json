{"sample_order": 8, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a hybrid strategy combining Best Fit and Worst Fit.\n\n    The priority is calculated as follows:\n    1. Compute the remaining capacities after placing the item in each bin.\n    2. Assign high priority to bins that can fit the item and have the smallest remaining space (Best Fit).\n    3. Assign low priority to bins that cannot fit the item.\n    4. Among the bins that can fit the item, assign higher priority to those with the smallest remaining space (Best Fit).\n    5. If all fitting bins have the same remaining space, assign higher priority to the bin with the largest original capacity (Worst Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    capacities_after_add = bins - item\n    can_fit = capacities_after_add >= 0\n    \n    # Initialize priorities with a large negative number for bins that cannot fit the item\n    priorities = np.full_like(bins, -np.inf)\n    \n    # Compute priorities for bins that can fit the item\n    fit_capacities = capacities_after_add[can_fit]\n    original_capacities = bins[can_fit]\n    \n    # Best Fit: prioritize bins with smallest remaining space\n    best_fit_priority = -fit_capacities\n    \n    # If remaining spaces are the same, prioritize bins with largest original capacity (Worst Fit aspect)\n    same_remaining_space = np.isclose(fit_capacities, fit_capacities.min())\n    worst_fit_priority = original_capacities * same_remaining_space\n    \n    # Combine priorities: Best Fit is primary, Worst Fit is secondary\n    combined_priority = best_fit_priority + worst_fit_priority\n    \n    # Assign priorities to the corresponding bins\n    priorities[can_fit] = combined_priority\n    \n    return priorities\n\n", "score": -212.0}