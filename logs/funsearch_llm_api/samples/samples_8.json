{"sample_order": 8, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Returns priority with which we want to add item to each bin with a hybrid of Best Fit and Worst Fit strategies.\n\n    This function aims to balance the Best Fit and Worst Fit strategies by combining their priorities. Best Fit tries to\n    place the item in the fullest bin that can still accommodate it, while Worst Fit places it in the least full bin.\n    This hybrid approach considers both by calculating a weighted average of the priorities from both strategies.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    best_fit_ratios = item / bins\n    best_fit_log_ratios = np.log(best_fit_ratios)\n    best_fit_priorities = -best_fit_log_ratios\n\n    worst_fit_ratios = (bins - item) / bins\n    worst_fit_log_ratios = np.log(worst_fit_ratios)\n    worst_fit_priorities = -worst_fit_log_ratios\n\n    # Combining the priorities with a weighted average\n    hybrid_priorities = 0.7 * best_fit_priorities + 0.3 * worst_fit_priorities\n\n    return hybrid_priorities\n\n", "score": -325.5}