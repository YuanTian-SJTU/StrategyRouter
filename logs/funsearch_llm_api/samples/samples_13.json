{"sample_order": 13, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a modified hybrid strategy.\n\n    Specifically, this function combines Best Fit and Worst Fit strategies, but \n    scales the contribution of each bin based on its remaining capacity relative \n    to the mean capacity of all bins. This adjustment aims to balance between \n    utilizing bins that fit the item well (Best Fit) and choosing bins that have\n    sufficient remaining space (Worst Fit), but weighted by their relative capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    mean_capacity = np.mean(bins)\n\n    # Best Fit component: prioritize bins that can accommodate the item with the least remaining space\n    best_fit_scores = -np.abs(bins - item)\n\n    # Worst Fit component: prioritize bins that have the most remaining space\n    worst_fit_scores = bins\n\n    # Scaling factors\n    scale_best = bins / mean_capacity if mean_capacity != 0 else 1.  # Avoid division by zero\n    # Invert scale_worst for proper weighting: originally, bins >= mean_capacity gives >= 1,\n    # scale_worst = scale_best**-1 would make bins < mean_capacity give > 1.\n    # Alternative approach: Prioritize scaling based on how much space *above* a threshold is available.\n    scale_worst = (bins - 0.5*mean_capacity) / mean_capacity if mean_capacity != 0 else 1.\n    scale_worst = np.maximum(scale_worst, 0.5)  # Apply a minimum weight to prevent zero or negative scaling\n\n    # Hybrid score: combine Best Fit and Worst Fit scores with normalized weights\n    # Use weights that emphasize bins closer to the item size and those with potentially ample space.\n    hybrid_scores = (0.6 * best_fit_scores * scale_best) + (0.4 * worst_fit_scores * scale_worst)\n\n    # Add a constraint penalty term to discourage adding item to bins where remaining space would fall below item size\n    # This prevents \"overfilling\" a bin.\n    penalty_threshold = bins - item\n    penalty_mask = (penalty_threshold <= 0).astype(float)\n\n", "score": null}