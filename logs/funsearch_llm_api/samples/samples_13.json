{"sample_order": 13, "strategy": "first_fit", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combination of Best Fit and Worst Fit strategies.\n    It first calculates the Best Fit priority (similar to priority_v0) but then adjusts the priority scores \n    by considering the remaining space in the bins after adding the item. This helps to balance the load \n    across bins by giving higher priority to bins that can accommodate the item while also having the most \n    remaining space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate Best Fit priority\n    ratios = item / (bins - item)\n    valid_bins = bins > item\n    ratios[~valid_bins] = float('inf')\n    best_fit_priorities = -np.log(ratios)\n    \n    # Calculate remaining space after adding the item\n    remaining_space = bins - item\n    remaining_space[~valid_bins] = -float('inf')\n    worst_fit_priorities = remaining_space\n    \n    # Combine the priorities: Best Fit for tight fit, Worst Fit for remaining space\n    combined_priorities = best_fit_priorities + worst_fit_priorities\n    \n    return combined_priorities\n\n", "score": -500.0}