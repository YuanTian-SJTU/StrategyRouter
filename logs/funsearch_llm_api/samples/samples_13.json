{"sample_order": 13, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid strategy\n       combining Best Fit and First Fit with weights based on remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component (lower ratio is better)\n    best_fit_ratios = item / bins\n    best_fit_scores = 1.0 / (best_fit_ratios + 1e-10)  # Avoid division by zero\n    \n    # First Fit component (earlier bins have higher priority if they can fit)\n    first_fit_scores = np.arange(len(bins), dtype=np.float64)\n    first_fit_mask = bins >= item\n    first_fit_scores[~first_fit_mask] = -np.inf  # Can't fit\n    \n    # Weight based on remaining capacity\n    weights = bins / np.sum(bins)\n    \n    # Combine both strategies with weights\n    combined_scores = weights * best_fit_scores + (1 - weights) * first_fit_scores\n    \n    return combined_scores\n\n", "score": -212.75}