{"sample_order": 10, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a Hybrid strategy.\n    \n    The hybrid strategy combines Best Fit and Worst Fit approaches:\n    1. For bins that can accommodate the item, calculate Best Fit priority.\n    2. For bins that are almost full (above 80% capacity), calculate Worst Fit priority.\n    3. Return the maximum priority score between the two strategies for each bin.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n        \n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component\n    ratios = item / bins\n    best_fit_priorities = -np.log(ratios)\n    \n    # Worst Fit component\n    worst_fit_priorities = np.log(bins - item)\n    \n    # Hybrid priority\n    hybrid_priorities = np.maximum(best_fit_priorities, worst_fit_priorities)\n    \n    # Apply mask for bins that can't accommodate the item\n    mask = bins > item\n    hybrid_priorities = np.where(mask, hybrid_priorities, -np.inf)\n    \n    return hybrid_priorities\n\n", "score": -500.0}