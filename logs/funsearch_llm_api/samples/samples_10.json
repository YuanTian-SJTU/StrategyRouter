{"sample_order": 10, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a multi-strategy approach \n    combining First Fit, Best Fit, Worst Fit, and Greedy Fit.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n        \n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # First Fit scores: prioritize the first bin that can accommodate the item\n    first_fit_scores = np.where(bins >= item, bins, -np.inf)\n    \n    # Best Fit scores: prioritize bins that can accommodate the item with the least remaining space\n    best_fit_scores = np.where(bins >= item, -np.abs(bins - item), -np.inf)\n    \n    # Worst Fit scores: prioritize bins that have the most remaining space\n    worst_fit_scores = np.where(bins >= item, bins, -np.inf)\n    \n    # Greedy Fit scores: prioritize bins that can accommodate the item with the smallest remaining space\n    greedy_fit_scores = np.where(bins >= item, bins - item, -np.inf)\n    \n    # Combine scores with weights\n    hybrid_scores = 0.25 * first_fit_scores + 0.25 * best_fit_scores + 0.25 * worst_fit_scores + 0.25 * greedy_fit_scores\n    \n    return hybrid_scores\n\n", "score": -500.0}