{"sample_order": 10, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid Best Fit and Worst Fit strategy.\n\n    This strategy calculates a priority score for each bin that is a weighted combination of the Best Fit (utilization)\n    and Worst Fit (avoiding fragmentation) strategies. The Best Fit component is based on the remaining capacity\n    after placing the item, while the Worst Fit component is based on the original bin capacity. The priorities are\n    normalized to the range [0, 1] for consistency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin, where higher values indicate higher priority.\n    \"\"\"\n    # Best Fit component: prioritize bins that can fit the item with the least remaining space\n    best_fit_component = bins - item\n    best_fit_priorities = -best_fit_component  # Smaller remaining space gets higher priority\n\n    # Worst Fit component: prioritize bins that have the largest capacity\n    worst_fit_component = bins\n    worst_fit_priorities = worst_fit_component  # Larger capacity gets higher priority\n\n    # Combine the two strategies with a weighted average (50% Best Fit, 50% Worst Fit)\n    combined_priorities = 0.5 * best_fit_priorities + 0.5 * worst_fit_priorities\n\n    # Normalize the combined priorities to the range [0, 1]\n    min_priority = np.min(combined_priorities)\n    max_priority = np.max(combined_priorities)\n    normalized_priorities = (combined_priorities - min_priority) / (max_priority - min_priority + 1e-10)\n\n    return normalized_priorities\n\n", "score": -212.75}