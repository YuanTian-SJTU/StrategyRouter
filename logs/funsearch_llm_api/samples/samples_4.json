{"sample_order": 4, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"\n    Hybrid strategy combining Best Fit and Worst Fit.\n    \n    This strategy aims to balance the Best Fit and Worst Fit approaches by:\n    - Prioritizing bins that have enough space to fit the item but are not overly empty.\n    - Penalizing bins that are either too small or too large for the item.\n    \n    The priority is calculated by a combination of the Best Fit (fit ratio) and Worst Fit (empty space) strategies.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate the space left in each bin if the item is added\n    space_left = bins - item\n    \n    # Calculate the fit ratio (item size / bin capacity)\n    fit_ratios = item / bins\n    \n    # Calculate the empty space ratio (space left / bin capacity)\n    empty_ratios = space_left / bins\n    \n    # Combine the fit ratio and empty space ratio to get the final priority\n    priorities = fit_ratios - 0.5 * empty_ratios\n    \n    return priorities\n\n", "score": -212.0}