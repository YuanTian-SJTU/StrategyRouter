{"sample_order": 4, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid strategy.\n\n    The hybrid strategy combines elements of:\n    - Best Fit: Prefers bins where the item fits with minimal waste.\n    - Greedy Fit: Prioritizes bins with the most remaining space.\n    - Avoidance of Overfill: Penalizes bins that would exceed capacity after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: prioritize bins where the remaining space after adding the item is smallest\n    remaining_space = bins - item\n    valid_bins = remaining_space >= 0\n    best_fit_priority = np.zeros_like(bins, dtype=float)\n    best_fit_priority[valid_bins] = 1.0 / (remaining_space[valid_bins] + 1e-6)  # Avoid division by zero\n\n    # Greedy Fit component: prioritize bins with the most remaining space\n    greedy_fit_priority = bins / (bins.sum() + 1e-6)  # Normalize by total bin capacity\n\n    # Avoidance of Overfill component: penalize bins that would be too full after adding the item\n    overfill_penalty = np.zeros_like(bins, dtype=float)\n    overfill_penalty[~valid_bins] = 1e6  # Large penalty for invalid bins (would overfill)\n\n    # Combine the priorities with weights\n    hybrid_priority = 0.5 * best_fit_priority + 0.4 * greedy_fit_priority + 0.1 * overfill_penalty\n\n    return hybrid_priority\n\n", "score": null}