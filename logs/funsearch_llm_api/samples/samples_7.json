{"sample_order": 7, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Hybrid strategy \n    that combines Best Fit and First Fit strategies. It first considers Best Fit priority \n    to minimize wastage but if multiple bins have the same Best Fit priority, it then uses \n    First Fit strategy to select the earliest suitable bin to maintain processing order.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: prioritize bins that leave the least remaining space\n    ratios = item / bins\n    best_fit_priorities = -np.log(ratios)\n    \n    # First Fit component: prioritize bins that can accommodate the item\n    first_fit_mask = (bins >= item)\n    first_fit_priorities = np.where(first_fit_mask, -1, 0)\n    \n    # Combine the strategies: Best Fit primary, First Fit secondary\n    combined_priorities = best_fit_priorities + first_fit_priorities\n    \n    return combined_priorities\n\n", "score": -500.0}