{"sample_order": 7, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a Hybrid strategy combining Best Fit and Worst Fit.\n\n    The strategy scores each bin based on the Best Fit strategy (aiming for a tight fit) and the Worst Fit strategy (avoiding overcrowding).\n    It then combines these scores with a weighted average, with more weight given to the Best Fit score to prioritize tight fits,\n    while still considering the Worst Fit score to avoid bins that are already too crowded.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit scores (lower ratios are better)\n    best_fit_ratios = item / bins\n    best_fit_scores = -best_fit_ratios  # Higher score for smaller ratios\n\n    # Worst Fit scores (higher remaining capacities are better)\n    remaining_capacities = bins - item\n    remaining_capacities[remaining_capacities <= 0] = np.inf  # Exclude bins that cannot fit the item\n    worst_fit_scores = remaining_capacities  # Higher score for larger remaining capacities\n\n    # Combine scores with a weighted average\n    alpha = 0.7  # Weight for Best Fit score\n    combined_scores = alpha * best_fit_scores + (1 - alpha) * worst_fit_scores\n\n    return combined_scores\n\n", "score": -500.0}