{"sample_order": 7, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid strategy\n    that combines Best Fit and Worst Fit with weights based on remaining capacity and item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Best Fit component: prioritize bins where the item fits with smallest possible remaining space\n    bf_ratios = item / bins\n    bf_priorities = -bf_ratios  # Lower ratio means better fit\n    \n    # Worst Fit component: prioritize bins with largest remaining space\n    wf_priorities = bins - item  # Higher remaining space is better\n    \n    # Dynamic weight based on item size and average bin capacity\n    avg_capacity = np.mean(bins)\n    weight = np.clip(item / (avg_capacity + 1e-6), 0.3, 0.7)\n    \n    # Combine priorities with dynamic weighting\n    priorities = weight * bf_priorities + (1 - weight) * wf_priorities\n    \n    return priorities\n\n", "score": null}