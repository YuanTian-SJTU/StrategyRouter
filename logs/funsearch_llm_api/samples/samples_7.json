{"sample_order": 7, "strategy": "hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a Hybrid strategy combining Best Fit and Worst Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining space in each bin\n    remaining_space = bins - item\n    \n    # Best Fit component: prioritize bins with remaining space closest to the item size but without exceeding the bin capacity\n    best_fit_priorities = -np.abs(remaining_space - item) * (remaining_space > 0).astype(float)\n    \n    # Worst Fit component: prioritize bins with the most remaining space\n    worst_fit_priorities = remaining_space * (remaining_space > 0).astype(float)\n    \n    # Combine Best Fit and Worst Fit components\n    combined_priorities = best_fit_priorities + worst_fit_priorities\n    \n    # Mask out bins where the item cannot fit\n    combined_priorities[remaining_space <= 0] = -np.inf\n    \n    return combined_priorities\n\n", "score": null}