{"sample_order": 7, "strategy": "Hybrid", "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with a hybrid strategy combining Best Fit and First Fit.\n\n    The strategy first tries to find the best fit (smallest remaining space that can still accommodate the item).\n    If there are multiple bins with the same best fit, this strategy then favors the first bin in the array\n    that can accommodate the item, following a First Fit approach.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity in each bin\n    remaining_capacities = bins - item\n    # Create a mask for bins that can accommodate the item\n    can_fit_mask = remaining_capacities >= 0\n    # Initialize priorities with a very large number for bins that can't fit the item\n    priorities = np.full_like(bins, np.inf)\n    \n    # Calculate the priority scores only for bins that can accommodate the item\n    priorities[can_fit_mask] = remaining_capacities[can_fit_mask]\n    \n    # For bins that can accommodate the item, we want to assign higher priority to those with smaller remaining capacities (Best Fit)\n    # Then, among bins with the same smallest remaining capacity (Best Fit result), we assign higher priority to the first one encountered (First Fit)\n    # To implement the First Fit part, we add a small correction that decreases the priority score as the index increases\n    correction = np.arange(len(bins)) * 1e-6\n    adjusted_priorities = priorities - correction\n    \n    return adjusted_priorities\n\n", "score": -500.0}