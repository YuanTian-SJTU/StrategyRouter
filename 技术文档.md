# 基于FunSearch的装箱问题优化系统技术文档

## 1. 系统概述

本系统是一个基于FunSearch框架的装箱问题（Bin Packing Problem）优化系统，通过大型语言模型（LLM）生成和评估不同的装箱策略，以寻找最优解决方案。系统集成了策略跟踪功能，能够识别、分类并评估不同类型的装箱策略（如First Fit、Best Fit、Worst Fit等），从而指导LLM生成更有效的策略。

### 1.1 装箱问题简介

装箱问题是一个经典的组合优化问题，目标是使用最少数量的容器（bins）来装载一系列具有不同大小的物品。在本系统中，我们专注于在线装箱问题（Online Bin Packing），即物品按顺序到达，系统需要立即决定将每个物品放入哪个容器中，且一旦决策做出就不能更改。

### 1.2 FunSearch框架

FunSearch（Functional Search）是一种结合大型语言模型和评估机制的优化框架，通过迭代生成和评估函数来解决复杂问题。在本系统中，FunSearch用于生成和优化装箱策略函数。

## 2. 系统架构

系统由以下主要组件构成：

1. **LLM API接口**：连接外部大型语言模型服务，生成装箱策略代码
2. **策略跟踪器**：识别、分类和记录不同装箱策略的性能
3. **沙箱执行环境**：安全执行和评估生成的代码
4. **性能可视化**：展示不同策略的性能变化和整体优化进程

## 3. 关键组件详解

### 3.1 LLM API接口（LLMAPI类）

`LLMAPI`类继承自`sampler.LLM`，负责与外部语言模型服务通信，生成装箱策略代码。

```python
class LLMAPI(sampler.LLM):
    """Language model that predicts continuation of provided source code."""

    def __init__(self, samples_per_prompt: int, trim=True):
        super().__init__(samples_per_prompt)
        self._trim = trim

    def draw_samples(self, prompt: str) -> Collection[str]:
        """Returns multiple predicted continuations of `prompt`."""
        return [self._draw_sample(prompt) for _ in range(self._samples_per_prompt)]
```

#### 主要功能：

1. **代码生成**：通过`_draw_sample`方法调用外部API（GLM-4-32B-0414）生成策略代码
2. **策略反馈**：将历史策略性能数据融入提示中，引导模型生成更优策略
3. **代码预处理**：使用`_trim_preface_of_body`函数处理生成的代码，移除冗余描述和函数声明

### 3.2 策略跟踪器（StrategyTracker类）

`StrategyTracker`类负责识别、分类和记录不同装箱策略的性能，为LLM提供反馈。

```python
class StrategyTracker:
    def __init__(self):
        self._strategy_scores: dict = {
            "hybrid": [],
            "first_fit": [],
            "best_fit": [],
            "worst_fit": [],
            "greedy": [],
            "other": []
        }
```

#### 主要功能：

1. **策略分类**：通过`classify_strategy`方法分析代码内容，将策略分类为First Fit、Best Fit、Worst Fit、Greedy、Hybrid或Other
2. **性能记录**：通过`update_score`方法更新各策略的性能分数
3. **性能反馈**：生成策略性能历史提示，帮助LLM了解不同策略的效果

### 3.3 沙箱执行环境（Sandbox类）

`Sandbox`类继承自`evaluator.Sandbox`，负责安全执行和评估生成的代码。

```python
class Sandbox(evaluator.Sandbox):
    """Sandbox for executing generated code."""

    def __init__(self, verbose=False, numba_accelerate=True):
        self._verbose = verbose
        self._numba_accelerate = numba_accelerate
        self._strategy_tracker = strategy_tracker.StrategyTracker()
```

#### 主要功能：

1. **代码执行**：在隔离环境中执行生成的代码，防止有害操作
2. **性能评估**：计算策略的得分（负的平均使用容器数量）
3. **超时控制**：防止无限循环等问题，确保评估过程可控
4. **性能优化**：可选使用Numba加速代码执行
5. **策略跟踪**：集成策略跟踪器，记录不同策略的性能

### 3.4 装箱问题规范（spec.py）

`spec.py`定义了装箱问题的核心算法和评估函数。

```python
def online_binpack(
        items: tuple[float, ...], bins: np.ndarray
) -> tuple[list[list[float, ...], ...], np.ndarray]:
    """Performs online binpacking of `items` into `bins`."""
    # Track which items are added to each bin.
    packing = [[] for _ in bins]
    # Add items to bins.
    for item in items:
        # Extract bins that have sufficient space to fit item.
        valid_bin_indices = get_valid_bin_indices(item, bins)
        # Score each bin based on heuristic.
        priorities = priority(item, bins[valid_bin_indices])
        # Add item to bin with highest priority.
        best_bin = valid_bin_indices[np.argmax(priorities)]
        bins[best_bin] -= item
        packing[best_bin].append(item)
    # Remove unused bins from packing.
    packing = [bin_items for bin_items in packing if bin_items]
    return packing, bins
```

#### 主要功能：

1. **在线装箱算法**：实现物品逐个放置的在线装箱过程
2. **评估函数**：计算策略在多个实例上的平均性能
3. **优先级函数**：定义将物品放入哪个容器的决策函数（由LLM优化）

## 4. 系统工作流程

### 4.1 初始化阶段

1. 加载装箱问题规范（spec.py）
2. 配置LLM API和沙箱环境
3. 准备测试数据集（OR3基准数据集）

### 4.2 迭代优化阶段

1. **代码生成**：LLM根据当前提示生成多个策略函数变体
2. **代码执行**：沙箱环境执行生成的代码，计算性能分数
3. **策略分类**：策略跟踪器分析代码，识别使用的策略类型
4. **性能记录**：更新各策略的性能历史
5. **反馈整合**：将性能数据整合到下一轮提示中

### 4.3 结果分析阶段

1. 绘制整体性能进展图表
2. 绘制各策略性能对比图表
3. 输出最终策略统计信息

## 5. 性能分析与可视化

### 5.1 基础可视化

系统提供两种基础可视化图表：

1. **整体性能进展**：展示所有样本中最佳分数的变化趋势
2. **策略性能对比**：展示不同策略（First Fit、Best Fit等）的性能变化

### 5.2 高级性能分析（PerformanceAnalyzer类）

`PerformanceAnalyzer`类提供了更为全面和深入的性能分析与可视化功能，专门用于对比策略层和函数变体层的性能表现，生成适合学术论文使用的高质量图表。

```python
class PerformanceAnalyzer:
    """分析和可视化策略层和函数变体层性能表现的类。"""
    
    def __init__(self):
        # 策略层数据
        self._strategy_data: Dict[str, Dict] = {}
        # 函数变体层数据
        self._variant_data: Dict[str, Dict] = {}
        # 设置默认的图表样式
        self._set_plot_style()
```

#### 主要功能：

1. **多维度数据收集**：分别在策略层和函数变体层收集性能数据
2. **统计分析**：计算各种性能指标，如最佳得分、平均得分、标准差等
3. **多样化图表生成**：提供多种可视化方式，包括：
   - 策略对比柱状图：直观比较不同策略的最佳和平均性能
   - 策略性能箱线图：展示各策略性能的分布特征
   - 策略演化曲线图：展示策略性能随迭代次数的变化趋势
   - 函数变体热力图：以热力图形式展示不同变体在不同迭代中的性能
   - 策略性能雷达图：多维度对比不同策略的各项指标
4. **报告生成**：自动生成完整的性能分析报告，包括图表和数据表格

## 6. 系统特点

1. **策略多样性**：支持多种装箱策略的生成和评估
2. **策略反馈**：通过策略跟踪器提供历史性能反馈，引导LLM生成更优策略
3. **安全执行**：沙箱环境确保生成代码的安全执行
4. **性能优化**：支持Numba加速代码执行
5. **多层次性能分析**：提供策略层和函数变体层的性能分析，支持多维度对比
6. **学术可视化**：生成适合学术论文使用的高质量图表，包括箱线图、热力图、雷达图等
7. **自动报告生成**：自动生成完整的性能分析报告，便于研究人员分析和比较不同策略

## 7. 使用指南

### 7.1 系统启动

```python
python funsearch_bin_packing_llm_api.py
```

### 7.2 配置参数

- `samples_per_prompt`：每轮生成的策略数量
- `evaluate_timeout_seconds`：评估超时时间
- `max_sample_nums`：最大样本数量

### 7.3 输出解释

- 控制台输出：显示每轮生成的策略类型和性能
- 基础图表输出：展示整体性能和各策略性能变化
- 性能统计表格：显示各策略的详细性能指标

### 7.4 性能分析报告

系统会自动在`performance_analysis`目录下生成完整的性能分析报告，包括：

1. **策略对比图**：`strategy_comparison.png`
   - 直观展示不同策略的最佳得分和平均得分
   - 包含样本数量标注

2. **策略箱线图**：`strategy_boxplot.png`
   - 展示各策略性能的分布特征
   - 包含中位数、四分位数和异常值

3. **策略演化图**：`strategy_evolution.png`
   - 展示各策略性能随迭代次数的变化趋势
   - 包含累积最佳性能曲线

4. **变体热力图**：`variant_heatmap.png`
   - 以热力图形式展示不同变体在不同迭代中的性能
   - 便于识别性能模式和趋势

5. **策略雷达图**：`strategy_radar.png`
   - 多维度对比不同策略的各项指标
   - 包括最佳得分、平均得分、稳定性和样本数量

6. **指标数据表**：`strategy_metrics.csv`
   - 包含所有策略的详细性能指标
   - 可导入到其他分析工具中进行进一步分析

### 7.5 自定义分析

研究人员可以通过以下方式进行自定义分析：

```python
# 创建性能分析器实例
from implementation import performance_analyzer
analyzer = performance_analyzer.PerformanceAnalyzer()

# 从策略跟踪器导入数据
analyzer.import_from_strategy_tracker(strategy_tracker_instance)

# 生成特定图表
fig = analyzer.plot_strategy_boxplot()
plt.show()

# 计算性能指标
metrics_df = analyzer.calculate_strategy_metrics()
print(metrics_df)
```

## 8. 总结

本系统通过结合大型语言模型和策略跟踪技术，实现了装箱问题的自动优化。系统能够生成、评估和改进多种装箱策略，并提供详细的性能分析和可视化工具。通过策略反馈机制，系统能够引导LLM生成更优的策略，从而不断提高装箱效率。

新增的性能分析模块（PerformanceAnalyzer）进一步增强了系统的分析能力，通过多维度数据收集和多样化图表生成，实现了策略层和函数变体层的深入性能对比。该模块生成的高质量可视化图表和详细性能指标，为研究人员提供了强大的工具，便于撰写学术论文和进行深入的算法分析。系统不仅能够优化装箱问题的解决方案，还能够帮助研究人员理解不同策略的性能特点和演化规律，为算法研究提供有力支持。